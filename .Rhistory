}
uppg4data <- data.frame(dVt = dVtvec, u = uxvec)
uppg5data <- data.frame(dVt = dVtvec2, u = uxvec2)
Vt4 <- uppg4data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt4 <- Vt4 %>% mutate(age = c(50:55))
Vt5 <- uppg5data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt5 <- Vt5 %>% mutate(age = seq(50,60, by = 0.5))
kable(Vt4)
knitr::kable(Vt4)
knitr::kable(Vt5)
AtBtVt %>% select(age, Vt)
knitr::kable(Vt5 %>% filter(age <= 55))
Vt4 <- Vt4[,c(2,1)]
Vt5 <- Vt5[,c(2,1)]
library(tidyverse)
library(readxl)
data <- data.frame(read_excel("Lifeinsurance/Laborationer/Laborationsdata.xls", sheet = 2))
data <- data %>% mutate(Dx = Dx/100000, Nx = Nx/100000)
colnames(data)[1] <- "age"
Pvalue <- function(data, x = 50, m = 30, n = 15, r = 0.027, S = 50000){
Dx <- data %>% filter(age >= x) %>% select(Dx)
Nx <- data %>% filter(age >= x) %>% select(Nx)
P = S*(Dx[1,1] - r*Nx[1,1] + r*Nx[(1+m/5),1])/(Nx[1,1] - Nx[(1+n/5),1])
return(P)
}
P <- Pvalue(data)
Btvalue <- function(data, x = 50, m = 30, n = 15){
Dx <- data %>% filter(age >= x) %>% select(Dx)
Nx <- data %>% filter(age >= x) %>% select(Nx)
Bt <- replicate(1+m/5,0)
for(i in 1:(1+n/5)){
Bt[i] <- P*(Nx[i,1] - Nx[1+n/5,1])/Dx[i,1]
}
return(Bt)
}
Atvalue <- function(data, x = 50, m = 30, r = .03, S = 50000){
Dx <- data %>% filter(age >= x) %>% select(Dx)
Nx <- data %>% filter(age >= x) %>% select(Nx)
At <- replicate(1+m/5,0)
for(i in 1:(1+m/5)){
At[i] <- S*(Dx[i,1] - r*Nx[i,1]+r*Nx[1+m/5,1])/Dx[i,1]
}
return(At)
}
deathInt <- function(data){
ux <- data$Dx/((lag(data$Nx)-data$Nx)/2)
return(ux)
}
ux <- deathInt(data)
yearPremie <- function(data, x = 50, n = 15){
Dx <- data %>% filter(age >= x) %>% select(Dx)
Nx <- data %>% filter(age >= x) %>% select(Nx)
A <- (Nx[1,1]-Nx[1+n/5,1])/Dx[1,1]
return(A)
}
A <- yearPremie(data)
Bt <- Btvalue(data)
At <- Atvalue(data)
AtBtVt <- data.frame(age = c(50, 55, 60, 65, 70, 75, 80),
ux = ux[11:17],
At = Atvalue(data),
Bt = Btvalue(data)) %>%
mutate(Vt = At - Bt,
dVt = 0.027*Vt + P - ux*(50000-Vt),
Risk = ux*(50000 - Vt),
Spar = P - Risk)
AtBtVt
AtBtVt %>% ggplot(aes(x = age, y = Vt)) +
geom_line()
knitr::kable(AtBtVt %>% select(age, Vt, Risk, Spar, dVt))
################
dVtvec <- c()
dVtvec[1] <- AtBtVt$dVt[1]
for (i in 2:6) {
dVtvec[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/5
}
dVtvec2 <- c()
dVtvec2[1] <- AtBtVt$dVt[1]
for (i in 2:11) {
dVtvec2[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/10
}
for (i in 12:21) {
dVtvec2[i] <- AtBtVt$dVt[2] + (i-11)*abs(AtBtVt$dVt[2]-AtBtVt$dVt[3])/10
}
uxtemp <- ux[11:13]
uxvec <- c()
uxvec[1] <- uxtemp[1]
for (i in 2:6) {
uxvec[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/5
}
uxvec2 <- c()
uxvec2[1] <- uxtemp[1]
for (i in 2:11) {
uxvec2[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/10
}
for (i in 12:21) {
uxvec2[i] <- uxtemp[2] + (i-11)*abs(uxtemp[2]-uxtemp[3])/10
}
uppg4data <- data.frame(dVt = dVtvec, u = uxvec)
uppg5data <- data.frame(dVt = dVtvec2, u = uxvec2)
Vt4 <- uppg4data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt4 <- Vt4 %>% mutate(age = c(50:55))
Vt4 <- Vt4[,c(2,1)]
Vt5 <- uppg5data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt5 <- Vt5 %>% mutate(age = seq(50,60, by = 0.5))
Vt5 <- Vt5[,c(2,1)]
data45table <- Vt4
data45table[3] <- Vt5[c(1,3,5,7,9),]
data45table[3] <- Vt5[c(1,3,5,7,9,11),]
data45table
data45table[3] <- Vt5[c(1,3,5,7,9,11),2]
data45table <- Vt4
data45table[3] <- Vt5[c(1,3,5,7,9,11),2]
data45table
data45table[4] <- AtBtVt %>% filter(age <=55) %>% select(Vt)
data45table
AtBtVt
data45table <- Vt4
data45table[3] <- Vt5[c(1,3,5,7,9,11),2]
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", AtBtVt[2,5])
data45table <- Vt4
data45table[3] <- Vt5[c(1,3,5,7,9,11),2]
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*", AtBtVt[2,5])
knitr::table(data45table)
knitr::kable(data45table)
colnames(data45table) <- c("Age", "h=1", "h=0.5", "Vt")
knitr::kable(data45table)
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2])
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2], "*",
"*", "*", "*", "*", "*", "*", "*")
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2], "*",
"*", "*", "*", "*", "*", "*", "*", "*", "*")
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*",
"*", "*", "*", "*", AtBtVt[2,5])
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*",
"*", "*", "*", "*", "*", "*", "*", "*",
"*", "*", "*", "*", AtBtVt[2,5])
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*",
"*", "*", "*", "*", "*", "*", "*", "*",
"*", "*", "*", "*", "*", "*", "*", AtBtVt[2,5])
colnames(data45table) <- c("Age", "h=1", "h=0.5", "Vt")
knitr::kable(data45table)
Vt4 <- uppg4data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt4 <- Vt4 %>% mutate(age = c(50:55))
dVtvec <- c()
dVtvec[1] <- AtBtVt$dVt[1]
for (i in 2:6) {
dVtvec[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/5
}
dVtvec2 <- c()
dVtvec2[1] <- AtBtVt$dVt[1]
for (i in 2:11) {
dVtvec2[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/10
}
for (i in 12:21) {
dVtvec2[i] <- AtBtVt$dVt[2] + (i-11)*abs(AtBtVt$dVt[2]-AtBtVt$dVt[3])/10
}
uxtemp <- ux[11:13]
uxvec <- c()
uxvec[1] <- uxtemp[1]
for (i in 2:6) {
uxvec[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/5
}
uxvec2 <- c()
uxvec2[1] <- uxtemp[1]
for (i in 2:11) {
uxvec2[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/10
}
for (i in 12:21) {
uxvec2[i] <- uxtemp[2] + (i-11)*abs(uxtemp[2]-uxtemp[3])/10
}
uppg4data <- data.frame(dVt = dVtvec, u = uxvec)
uppg5data <- data.frame(dVt = dVtvec2, u = uxvec2)
Vt4 <- uppg4data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt4 <- Vt4 %>% mutate(age = c(50:55))
Vt4 <- round(Vt4[,c(2,1)], 3)
Vt5 <- uppg5data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt5 <- Vt5 %>% mutate(age = seq(50,60, by = 0.5))
Vt5 <- round(Vt5[,c(2,1)], 3)
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2], "*",
"*", "*", "*", "*", "*", "*", "*", "*", "*")
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*",
"*", "*", "*", "*", "*", "*", "*", "*",
"*", "*", "*", "*", "*", "*", "*", AtBtVt[2,5])
colnames(data45table) <- c("Age", "h=1", "h=0.5", "Vt")
knitr::kable(data45table)
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2], "*",
"*", "*", "*", "*", "*", "*", "*", "*", "*")
dVtvec <- c()
dVtvec[1] <- AtBtVt$dVt[1]
for (i in 2:6) {
dVtvec[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/5
}
dVtvec2 <- c()
dVtvec2[1] <- AtBtVt$dVt[1]
for (i in 2:11) {
dVtvec2[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/10
}
for (i in 12:21) {
dVtvec2[i] <- AtBtVt$dVt[2] + (i-11)*abs(AtBtVt$dVt[2]-AtBtVt$dVt[3])/10
}
uxtemp <- ux[11:13]
uxvec <- c()
uxvec[1] <- uxtemp[1]
for (i in 2:6) {
uxvec[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/5
}
uxvec2 <- c()
uxvec2[1] <- uxtemp[1]
for (i in 2:11) {
uxvec2[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/10
}
for (i in 12:21) {
uxvec2[i] <- uxtemp[2] + (i-11)*abs(uxtemp[2]-uxtemp[3])/10
}
uppg4data <- data.frame(dVt = dVtvec, u = uxvec)
uppg5data <- data.frame(dVt = dVtvec2, u = uxvec2)
Vt4 <- uppg4data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt4 <- Vt4 %>% mutate(age = c(50:55))
Vt4 <- round(Vt4[,c(2,1)], 3)
Vt5 <- uppg5data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt5 <- Vt5 %>% mutate(age = seq(50,60, by = 0.5))
Vt5 <- round(Vt5[,c(2,1)], 3)
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2], "*",
"*", "*", "*", "*", "*", "*", "*", "*", "*")
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*",
"*", "*", "*", "*", "*", AtBtVt[2,5], "*", "*",
"*", "*", "*", "*", "*", "*", "*", AtBtVt[3,5])
colnames(data45table) <- c("Age", "h=1", "h=0.5", "Vt")
knitr::kable(data45table)
AtBtVt <- round(AtBtVt, 3)
data45table <- Vt5
dVtvec <- c()
dVtvec[1] <- AtBtVt$dVt[1]
for (i in 2:6) {
dVtvec[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/5
}
dVtvec2 <- c()
dVtvec2[1] <- AtBtVt$dVt[1]
for (i in 2:11) {
dVtvec2[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/10
}
for (i in 12:21) {
dVtvec2[i] <- AtBtVt$dVt[2] + (i-11)*abs(AtBtVt$dVt[2]-AtBtVt$dVt[3])/10
}
uxtemp <- ux[11:13]
uxvec <- c()
uxvec[1] <- uxtemp[1]
for (i in 2:6) {
uxvec[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/5
}
uxvec2 <- c()
uxvec2[1] <- uxtemp[1]
for (i in 2:11) {
uxvec2[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/10
}
for (i in 12:21) {
uxvec2[i] <- uxtemp[2] + (i-11)*abs(uxtemp[2]-uxtemp[3])/10
}
uppg4data <- data.frame(dVt = dVtvec, u = uxvec)
uppg5data <- data.frame(dVt = dVtvec2, u = uxvec2)
Vt4 <- uppg4data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt4 <- Vt4 %>% mutate(age = c(50:55))
Vt4 <- round(Vt4[,c(2,1)], 3)
Vt5 <- uppg5data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt5 <- Vt5 %>% mutate(age = seq(50,60, by = 0.5))
Vt5 <- round(Vt5[,c(2,1)], 3)
AtBtVt <- round(AtBtVt, 3)
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2], "*",
"*", "*", "*", "*", "*", "*", "*", "*", "*")
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*",
"*", "*", "*", "*", "*", AtBtVt[2,5], "*", "*",
"*", "*", "*", "*", "*", "*", "*", AtBtVt[3,5])
colnames(data45table) <- c("Age", "h=1", "h=0.5", "Vt")
knitr::kable(data45table, caption = "Värdefunktionen beräknade med Thieles för steglängd 0.5 och 1 samt Vt beräknat med At och Bt")
dVtvec <- c()
dVtvec[1] <- AtBtVt$dVt[1]
for (i in 2:6) {
dVtvec[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/5
}
dVtvec2 <- c()
dVtvec2[1] <- AtBtVt$dVt[1]
for (i in 2:11) {
dVtvec2[i] <- AtBtVt$dVt[1] + (i-1)*abs(AtBtVt$dVt[1]-AtBtVt$dVt[2])/10
}
for (i in 12:21) {
dVtvec2[i] <- AtBtVt$dVt[2] + (i-11)*abs(AtBtVt$dVt[2]-AtBtVt$dVt[3])/10
}
uxtemp <- ux[11:13]
uxvec <- c()
uxvec[1] <- uxtemp[1]
for (i in 2:6) {
uxvec[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/5
}
uxvec2 <- c()
uxvec2[1] <- uxtemp[1]
for (i in 2:11) {
uxvec2[i] <- uxtemp[1] + (i-1)*abs(uxtemp[1]-uxtemp[2])/10
}
for (i in 12:21) {
uxvec2[i] <- uxtemp[2] + (i-11)*abs(uxtemp[2]-uxtemp[3])/10
}
uppg4data <- data.frame(dVt = dVtvec, u = uxvec)
uppg5data <- data.frame(dVt = dVtvec2, u = uxvec2)
Vt4 <- uppg4data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt4 <- Vt4 %>% mutate(age = c(50:55))
Vt4 <- round(Vt4[,c(2,1)], 3)
Vt5 <- uppg5data %>% mutate(Vt = (dVt+u*50000 - P)/(0.027+u)) %>% select(Vt)
Vt5 <- Vt5 %>% mutate(age = seq(50,60, by = 0.5))
Vt5 <- round(Vt5[,c(2,1)], 3)
AtBtVt <- round(AtBtVt, 3)
data45table <- Vt5
data45table[3] <- c(Vt4[1,2], "*", Vt4[2,2], "*", Vt4[3,2], "*",
Vt4[4,2], "*", Vt4[5,2], "*", Vt4[6,2], "*",
"*", "*", "*", "*", "*", "*", "*", "*", "*")
data45table[4] <- c(AtBtVt[1,5], "*", "*", "*", "*",
"*", "*", "*", "*", "*", AtBtVt[2,5], "*", "*",
"*", "*", "*", "*", "*", "*", "*", AtBtVt[3,5])
colnames(data45table) <- c("Age", "h=1", "h=0.5", "Vt")
knitr::kable(data45table, caption = "Värdefunktionen beräknade med Thieles för steglängd 0.5 och 1 samt Vt beräknat med At och Bt")
library(dplyr)
library(ggplot2)
library(VGAM)
data <- read.table("Wine/wine.data", sep = ",")
#Data on form (group,x_1,x_2)
Linear <- function(data){
colnames(data) <- c("V1","V2","V3")
#average group
agroup <- (min(data[,1])+max(data[,1]))/2
library(lattice)
with(data, xyplot(V3 ~ V2,groups = V1, col=c('blue', 'orange')))
# now fit two models
# model 1: linear regression
lmfits <- lm(V1 ~ V2 + V3 , data = data)
# get the slope and intercept for the decision boundary
#Intercept -1.5 because are groups 1 and 2
intercept <- -(lmfits$coef[1] - agroup) / lmfits$coef[3]
slope <- - lmfits$coef[2] / lmfits$coef[3]
# Figure 2.1
xyplot(V3 ~ V2, groups = V1, col = c('blue', 'orange'), data = data,
panel = function(...)
{
panel.xyplot(...)
panel.abline(intercept, slope)
},
main = 'Linear Regression of 1/2 Response')
}
kNearest <- function(data, k = 15){
colnames(data) <- c("V1","V2","V3")
# model2: k nearest-neighbor methods
library(class)
# get the range of x1 and x2
rx1 <- range(data$V2)
rx2 <- range(data$V3)
# get lattice points in predictor space
px1 <- seq(from = rx1[1], to = rx1[2], by = 0.05 )
px2 <- seq(from = rx2[1], to = rx2[2], by = 0.05 )
xnew <- expand.grid(x1 = px1, x2 = px2)
# get the contour map
knn15 <- knn(train = data[,2:3], test = xnew, cl = data[,1], k = k, prob = TRUE)
prob <- attr(knn15, "prob")
#toString() was just "1" in 0/1 case
prob <- ifelse(knn15==toString(max(data[,1])), prob, 1-prob)
prob15 <- matrix(prob, nrow = length(px1), ncol = length(px2))
# Figure 2.2
par(mar = rep(2,4))
contour(px1, px2, prob15, levels=0.5, labels="", xlab="", ylab="", main=
"15-nearest neighbour", axes=FALSE)
points(data[,2:3], col=ifelse(data[,1]==max(data[,1]), "coral", "cornflowerblue"))
points(xnew, pch=".", cex=1.2, col=ifelse(prob15>0.5, "coral", "cornflowerblue"))
box()
}
data <- as.data.frame(data)
datanew <- data %>% filter(V1!=1) %>% dplyr::select(V1,V2,V3)
library(dplyr)
getwd()
data <- read.table("Statistical learning/Project/Wine/wine.data", sep = ",")
library(dplyr)
library(ggplot2)
library(VGAM)
data <- read.table("Statistical learning/Project/Wine/wine.data", sep = ",")
#Data on form (group,x_1,x_2)
Linear <- function(data){
colnames(data) <- c("V1","V2","V3")
#average group
agroup <- (min(data[,1])+max(data[,1]))/2
library(lattice)
with(data, xyplot(V3 ~ V2,groups = V1, col=c('blue', 'orange')))
# now fit two models
# model 1: linear regression
lmfits <- lm(V1 ~ V2 + V3 , data = data)
# get the slope and intercept for the decision boundary
#Intercept -1.5 because are groups 1 and 2
intercept <- -(lmfits$coef[1] - agroup) / lmfits$coef[3]
slope <- - lmfits$coef[2] / lmfits$coef[3]
# Figure 2.1
xyplot(V3 ~ V2, groups = V1, col = c('blue', 'orange'), data = data,
panel = function(...)
{
panel.xyplot(...)
panel.abline(intercept, slope)
},
main = 'Linear Regression of 1/2 Response')
}
kNearest <- function(data, k = 15){
colnames(data) <- c("V1","V2","V3")
# model2: k nearest-neighbor methods
library(class)
# get the range of x1 and x2
rx1 <- range(data$V2)
rx2 <- range(data$V3)
# get lattice points in predictor space
px1 <- seq(from = rx1[1], to = rx1[2], by = 0.05 )
px2 <- seq(from = rx2[1], to = rx2[2], by = 0.05 )
xnew <- expand.grid(x1 = px1, x2 = px2)
# get the contour map
knn15 <- knn(train = data[,2:3], test = xnew, cl = data[,1], k = k, prob = TRUE)
prob <- attr(knn15, "prob")
#toString() was just "1" in 0/1 case
prob <- ifelse(knn15==toString(max(data[,1])), prob, 1-prob)
prob15 <- matrix(prob, nrow = length(px1), ncol = length(px2))
# Figure 2.2
par(mar = rep(2,4))
contour(px1, px2, prob15, levels=0.5, labels="", xlab="", ylab="", main=
"15-nearest neighbour", axes=FALSE)
points(data[,2:3], col=ifelse(data[,1]==max(data[,1]), "coral", "cornflowerblue"))
points(xnew, pch=".", cex=1.2, col=ifelse(prob15>0.5, "coral", "cornflowerblue"))
box()
}
data <- as.data.frame(data)
datanew <- data %>% filter(V1!=1) %>% dplyr::select(V1,V2,V3)
Linear(datanew)
kNearest(datanew, k=15)
Linear(datanew)
allstockNames <- getNames("Data/stocks.csv")
setwd("C:/Users/maxlu/iCloudDrive/Documents/Kurser/MasterThesis/BayesianOptimalPortfolio")
library(tidyquant)
library(plotly)
library(tidyverse)
library(timetk)
# get list of names from a imported yahoo portfolio
source("getNamesFinance.R")
# Gathers stock data in nested list
#source("getData.R")
stockNames <- getNames("Data/quotes.csv")
allstockNames <- getNames("Data/stocks.csv")
# Create dataframe containing adjusted price for each stock and time
# Maybe later
# Doing analysis from post "https://www.codingfinance.com/post/2018-04-20-portfolio-stats/" for
#Select stocks to analyze
tick <- stockNames[-1] %>% head(8) %>% str_sort()
fullNames <- get_stock_name(tick)
tick <- c("AAPL",tick)
tick
# Select stocks incase tick contains all possible stocks
#tick <- tick[c(2,13,59,77,80,86)]
#download price data
price_data <- tq_get(tick,
from = '2019-06-29',
to = '2020-12-29',
get = 'stock.prices')
price_data
price_data %>% head(100)
# Calculate daily returns for assets
ret_data <- price_data %>%
group_by(symbol) %>%
tq_transmute(select = adjusted,
mutate_fun = periodReturn,
period = "daily",
col_rename = "ret")
# Wide format
ret_data_wide <- ret_data %>%
spread(symbol, value = ret) %>%
tk_xts()
ret_data_wide
price_data[,-c(1,2)] <- na.approx(price_data[,-c(1,2)])
# Calculate daily returns for assets
ret_data <- price_data %>%
group_by(symbol) %>%
tq_transmute(select = adjusted,
mutate_fun = periodReturn,
period = "daily",
col_rename = "ret")
# Wide format
ret_data_wide <- ret_data %>%
spread(symbol, value = ret) %>%
tk_xts()
ret_data_wide
??na.approx
ret_data
ret_data <- na.approx(ret_data)
# Wide format
ret_data_wide <- ret_data %>%
spread(symbol, value = ret) %>%
tk_xts()
ret_data_wide
ret_data_wide <- na.approx(ret_data_wide)
ret_data_wide
